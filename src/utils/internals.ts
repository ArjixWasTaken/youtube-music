import type { Store } from 'redux';

export const YTMD_INTERNALS_CONSTANT =
  '__YTMD_INTERNALS_DO_NOT_TOUCH_OTHERWISE_YOU_DIE__';

export enum InjectionToken {
  NETWORK_TOKEN = 'NETWORK_TOKEN',
  KEY_MANAGER_TOKEN = 'KEY_MANAGER_TOKEN',
  GFEEDBACK_TOKEN = 'GFEEDBACK_TOKEN',
  ENDPOINT_HANDLER_TOKEN = 'ENDPOINT_HANDLER_TOKEN',
  COMMAND_HANDLER_TOKEN = 'COMMAND_HANDLER_TOKEN',
  CLIENT_NAME_TOKEN = 'CLIENT_NAME_TOKEN',
  DEFAULT_STORE_EXPIRATION_TOKEN = 'DEFAULT_STORE_EXPIRATION_TOKEN',
  SCHEDULER_TOKEN = 'SCHEDULER_TOKEN',
  WATCH_PLAYER_PROMISE_TOKEN = 'WATCH_PLAYER_PROMISE_TOKEN',
  MODULE_REGISTRY_TOKEN = 'MODULE_REGISTRY_TOKEN',
  PERSISTENT_STORE_PROMISE_ACCESSOR_TOKEN = 'PERSISTENT_STORE_PROMISE_ACCESSOR_TOKEN',
  EPHEMERAL_STORE_TOKEN = 'EPHEMERAL_STORE_TOKEN',
  ENTITY_STATE_TOKEN = 'ENTITY_STATE_TOKEN',
  STATE_STORE_TOKEN = 'STATE_STORE_TOKEN',
  PERSISTENT_ENTITY_STORE_ACCESSOR_TOKEN = 'PERSISTENT_ENTITY_STORE_ACCESSOR_TOKEN',
  AUTH_SERVICE_TOKEN = 'AUTH_SERVICE_TOKEN',
  ENDPOINT_MAP = 'ENDPOINT_MAP',
  SCREEN_MANAGER_TOKEN = 'SCREEN_MANAGER_TOKEN',
  DOWNLOAD_UPLIFT_SERVICE_TOKEN = 'DOWNLOAD_UPLIFT_SERVICE_TOKEN',
  ACTIVITY_TOKEN = 'ACTIVITY_TOKEN',
  ACTION_ROUTER_TOKEN = 'ACTION_ROUTER_TOKEN',
  DOWNLOAD_ELIGIBILITY_PROMISE_TOKEN = 'DOWNLOAD_ELIGIBILITY_PROMISE_TOKEN',
  PREF_STORAGE_PROMISE_TOKEN = 'PREF_STORAGE_PROMISE_TOKEN',
  DOWNLOADS_ENTITY_TYPE_MAP = 'DOWNLOADS_ENTITY_TYPE_MAP',
  DIALOG_CONTROLLER_TOKEN = 'DIALOG_CONTROLLER_TOKEN',
  PANEL_LOADING_STRATEGY_TOKEN = 'PANEL_LOADING_STRATEGY_TOKEN',
  SHEET_CONTROLLER_TOKEN = 'SHEET_CONTROLLER_TOKEN',
  APP_DIRECTION_TOKEN = 'APP_DIRECTION_TOKEN',
  ICON_SET_TOKEN = 'ICON_SET_TOKEN',
  ICON_MANAGER_TOKEN = 'ICON_MANAGER_TOKEN',
  PREFETCH_ICONS_TOKEN = 'PREFETCH_ICONS_TOKEN',
  DOWNLOAD_UPLIFT_COMPLETION_PROMISE_TOKEN = 'DOWNLOAD_UPLIFT_COMPLETION_PROMISE_TOKEN',
  LOCAL_INNERTUBE_SERVICE_MAP_TOKEN = 'LOCAL_INNERTUBE_SERVICE_MAP_TOKEN',
  LOCAL_INNERTUBE_ROUTER_TOKEN = 'LOCAL_INNERTUBE_ROUTER_TOKEN',
  NETWORK_MANAGER_TOKEN = 'NETWORK_MANAGER_TOKEN',
  VOTING_ANIMATION_CONTROLLER_TOKEN = 'VOTING_ANIMATION_CONTROLLER_TOKEN',
  INNERTUBE_TOKEN_SERVICE = 'INNERTUBE_TOKEN_SERVICE',
  ENTITIES_RESPONSE_PROCESSOR_TOKEN = 'ENTITIES_RESPONSE_PROCESSOR_TOKEN',
  INNERTUBE_TRANSPORT_TOKEN = 'INNERTUBE_TRANSPORT_TOKEN',
  ICON_WIZ_COMPONENT_TOKEN = 'ICON_WIZ_COMPONENT_TOKEN',
  BUTTON_RENDERER_TOKEN = 'BUTTON_RENDERER_TOKEN',
  DARK_THEME_TOKEN = 'DARK_THEME_TOKEN',
  TOAST_MANAGER_TOKEN = 'TOAST_MANAGER_TOKEN',
  POPUP_CONTROLLER_TOKEN = 'POPUP_CONTROLLER_TOKEN',
  PANEL_CONTROLLER_TOKEN = 'PANEL_CONTROLLER_TOKEN',
  PURCHASE_MANAGER_TOKEN = 'PURCHASE_MANAGER_TOKEN',
  APP_STORE_TOKEN = 'APP_STORE_TOKEN',
  VISIBILITY_OBSERVER = 'VISIBILITY_OBSERVER',
  PLAYER_API_TOKEN = 'PLAYER_API_TOKEN',
  NAVIGATION_PROGRESS_TOKEN = 'NAVIGATION_PROGRESS_TOKEN',
}

// TODO: Document all other services here
type InjectedService = {
  [InjectionToken.TOAST_MANAGER_TOKEN]: {
    currentPersistentToast: unknown;
    currentToast: unknown;
    queue: unknown[];

    enqueue(a: unknown, b: unknown): void;
  };

  [InjectionToken.APP_STORE_TOKEN]: {
    // TODO: Write types for all members
    store: Store<{
      castStatus: unknown;
      collabInviteLink: unknown;
      continuation: unknown;
      download: unknown;
      entities: unknown;
      home: unknown;
      likeStatus: unknown;
      multiSelect: unknown;
      navigation: unknown;
      player: unknown;
      playerPage: unknown;
      queue: unknown;
      radioButtonGroup: unknown;
      subscribeStatus: unknown;
      toggleStates: unknown;
      ui: unknown;
      uploads: unknown;
    }>;
  };
};

export const resolveToken = async <
  T extends InjectionToken,
  R = T extends keyof InjectedService ? InjectedService[T] : unknown,
>(
  token: T,
): Promise<R | undefined> => {
  const { container } = (globalThis as any)[YTMD_INTERNALS_CONSTANT] ?? {};
  if (!container) return undefined;

  const [injectionToken] =
    container.providers.entries().find(([key]: [any]) => key?.name === token) ??
    [];

  if (!injectionToken) return undefined;
  return await container.resolve(injectionToken);
};
